---
title: "Lab09"
output:
  html_document: 
    toc: TRUE
    code_folding: show
    theme: spacelab
    highlight: espresso
---
#MongoDB
  O MongoDB é um banco de dados NoSQL focado em alta performance e amplamente utilizado em aplicações web e cenários envolvendo big data. O software é livre e gratuito, podendo ser obtido diretamente em https://www.mongodb.com/.

#Objetivos
  Ao fim deste laboratório, você deverá ser capaz de:

 - Conectar-se a um banco de dados do tipo MongoDB utilizando o R como interface;
 - Realizar pesquisas simples;
 - Realizar consultas em campos aninhados;
 - Inserir dados em coleções;
 - Importar dados;
 - Exportar dados;
 - Determinar estatísticas de interesse por meio de operações agregadas.

#Instalação de pacotes essenciais
  Os pacotes que são essenciais para a execução deste laboratório podem ser instalados de acordo com o snippet abaixo.
  
  - Execute esta instalação antes de tentar criar um novo documento RMarkdown. Se o sistema perguntar sobre instalar novos pacotes a partir do código-fonte (install newer version from source), responda n (para indicar não).

```{r eval=FALSE}
options(install.packages.check.source = "no")
pkgs = c('tidyverse', 'rmarkdown', 'knitr', 'caTools', 
         'jsonlite', 'magrittr', 'mongolite')
install.packages(pkgs, type='win.binary')
```

#Fonte do Problema
  Para este laboratório, serão utilizadas algumas observações do conjunto de dados diamonds disponibilizado via ggplot2.
  
##Atividade

###Questão 01
  Conecte-se ao servidor mongo.opencpu.org usando a porta 43942 para o banco de dados jeroen_test. O usuário a ser utilizado é  readwrite e a senha é test. Para esta conexão, crie uma coleção nomeada diamonds_970308, assumindo que o seu RA seja 970308. O objeto retornado deve ser armazenado na variável con.

```{r Q1}
library(tibble)
library(mongolite)

colecao <- "diamonds_137408"
myurl <- "mongodb://dbadmin:adeamorbdebochecha0@ds147213.mlab.com:47213/mdb_helton"
con <- mongo(colecao,
             url = myurl)

```


###Questão 02
  Exiba o conteúdo de con. Explore o método insert() e descreva textualmente que tipo de objeto o argumento data pode receber.

```{r Q2}
print(con)

#?mongo
```

**Método insert**: O método insert adiciona linhas em uma coleção, as linhas são passadas por meio do argumento *data*. O argumento pode ser uma lista, para um registro único, um vetor de caracteres com registros json (um registro por string) ou então um data frame.

###Questão 03
  Explore o conjunto de dados diamonds que é distribuído por meio do pacote ggplot2. Quantas observações e quantas colunas possui este conjunto de dados? 

```{r Q3a}
library(ggplot2)
library(magrittr)

#Cara do conjunto de dados
diamonds %>% 
  head(5)

#Dimensões (linhas colunas)
diamonds %>% 
  dim()


```

  Configure a semente aleatória do R para ser o valor numérico do seu RA, sorteie aleatóriamente 500 observações e as armazene no objeto mydiamonds.

```{r Q3b}
#Amostra aleatória de 500 observações com a semente 137408
set.seed(137408)

library(dplyr)
mydiamonds <- sample_n(diamonds, 500)
```


###Questão 04
  Grave o banco de dados acima na coleção MongoDB criada na Questão 1.

```{r Q4}
con$insert(mydiamonds)
```


###Questão 05
  Recupere do banco de dados as informações de todos os diamantes cuja variável cut seja igual a Premium e custem menos de USD 1.000,00. Armazene o resultado na variável p1000a. 

```{r Q5a}

p1000a <- con$find(query = '{
                   "cut":"Premium", 
                   "price":{ "$lt" : 1000}}'
                   )

```

  Quantos diamantes ‘premium’ custam menos de 1.000 dólares na sua amostra?

```{r Q5b}

p1000a %>% 
  nrow()

```


###Questão 06
  Para a consulta acima, refaça a chamada via MongoDB, de forma a obter apenas as colunas cut, clarity e price. Armazene o resultado na variável p1000b.

```{r Q6}

p1000b <- con$find(query = '{
                     "cut":"Premium", 
                     "price":{ "$lt" : 1000}}',
                   fields = '{
                     "_id":0,
                     "cut":1,
                     "clarity":1,
                     "price":1}'
                  )

```


###Questão 07
  Refaça a consulta do Item 6 e retorne apenas os 5 diamantes mais caros presentes nesta amostra. O resultado deve ser armazenado na variável p1000c.

```{r Q7}
p1000c <- con$find(query = '{
                    "cut":"Premium",
                    "price":{ "$lt":1000 }}',
                  fields = '{
                    "_id":0,
                    "cut":1,
                    "clarity":1,
                    "price":1}',
                  sort = '{"price":-1}',
                  limit = 5)
```


###Questão 08
  Consulte o banco de dados (500 observações) para identificar qual é o diamante mais caro presente na sua amostra. Qual foi o tempo total de execução desta consulta?

```{r Q8}
inicio <- Sys.time()

  con$find(sort = '{"price":-1}',
           limit = 1)

fim <- Sys.time()
durQ8 <- fim - inicio
print(durQ8)
```


###Questão 09
  Crie um índice para a variável price.

```{r Q9}
con$index('{"price":-1}')
#-1 decrescente
#1 crescente

#O que esse índice faz?
#Parece que já deixa um registro da sequência ordenada de forma decrescente pela variável price, daí não precisa fazer as comparações, apenas buscar a posição no índice.
```


###Questão 10
  Refaça a Questão 8, agora que um índice foi criado.

```{r Q10}
inicio <- Sys.time()

  con$find(sort = '{"price":-1}',
           limit = 1)

fim <- Sys.time()
durQ10 <- fim - inicio
print(durQ10)

```


    **Observação**: Diferenças entre os tempos de execução das Questões 8 e 10 serão mínimas, assumindo que aconteçam. Estas diferenças poderão ser notadas mais explicitamente se o servidor do MongoDB for local. Pelo fato de estarmos utilizando um servidor público via internet, a maior parte do tempo mensurado é devido à conexão propriamente dita.

```{r OBS}
durQ8-durQ10
```


###Questão 11
  Utilize o método iterate() para trabalhar com lotes de linhas do banco de dados. Armazene o resultado de interate() na variável it. Explore a documentação do método e realize a iteração apenas para diamantes de cut="Premium", ordenando por preço (de maneira decresente). 

```{r Q11a}
it <- con$iterate(query = '{"cut":"Premium"}',
                  sort = '{"price":-1}')

print(it)
```

  Aplique o método batch(n), com n=100, para determinar as estatísticas suficientes da média de preços. Saiba que, muito provavelmente, ao chegar ao fim do banco de dados, o número de observações no seu subconjunto será inferior ao tamanho do lote (100).

```{r Q11b}
lote <- 100
parada <- FALSE

resultado <- vector('list', 1000)
i <- 1

while(!parada){
  # extrai as 100 primeiras observações de corte Premium
  x <- it$batch(lote)
  
  # O resultado da função batch é uma lista de listas, uma lista onde cada elemento é uma lista que corresponde a um registro json. Para cara registro json transformamos em data frame, dai temos uma lista de data frames. Para cada elemento da lista, ou seja, para cada data frame, fazemos a união por linhas.
  x <- do.call(what = rbind,
               args = lapply(x,
                             FUN = as.data.frame))
  
  # Obtemos as estatísticas suficientes e guardamos em uma lista pré carregada com tamanho 1000 (se deixar para o R consultar o tamanho e adicionar um novo elemento o processo fica muito mais lento).
  resultado[[i]] <- x %>% 
    summarise(soma=sum(price),
              n=n())
  
  # Critério de parada: Se a quantidade de linhas obtidas na iteração for menor que o lote pedido, então chegamos ao fim dos dados. Precisaria colocar um teste de erro para o caso onde a quantidade de registros é multipla do tamanho do lote.
  parada <- nrow(x)<lote
  
  i <- i + 1
}

# Agora temos uma lista de data frames, cada um com medidas das estatísticas suficientes, primeiro transformamos tudo em um único data frame depois obtemos as estatísticas suficientes. Como sempre guardamos os data frames na posição i, então temos i-1 elementos da lista preenchidos.
resultado <- do.call(what = rbind,
                     args = resultado[1:(i-1)]) %>% 
  summarise(media = sum(soma)/sum(n))
```

```{r eval=FALSE}
#Dicas do Benilton

lst = list(a= 1, b=3, c=4)
lst
as.data.frame(lst)
lst = list(obs1 = list(a= 1, b=3, c=4), obs2 = list(a= 3, b=5, c=7))
lst
as.data.frame(lst)
lapply(lst, as.data.frame)

do.call(rbind, lapply(lst, as.data.frame))

#pesquisar dplyr::bind_rows()
```

###Questão 12
  Utilize o método aggregate() para determinar o número de diamantes e o respectivo preço médio, estratificando pela variável cut. Renomeie as colunas para que sejam, respectivamente, tipo, n e media. 

```{r Q12a}
#https://jeroen.github.io/mongolite/calculation.html#aggregate
#https://docs.mongodb.com/manual/aggregation/
#vou dar um group by em cut, calcular o n e o preco medio. Vou ficar com tipo, n e media.

adb <- con$aggregate(pipeline = '[{
                "$group": {
                  "_id": "$cut",
                  "n": {"$sum":1},
                  "media": {"$avg": "$price"}
              }}]')

names(adb) <- c("tipo", "n", "media")
print(adb)
```
Use o ggplot2 para apresentar um gráfico de barras com o preço.
```{r Q12b}
library(ggplot2)

adb %>% ggplot(aes(x=tipo, y=media)) +
  geom_col()
```

###Questão 13
  Utilizando o método export(), exporte o banco de dados para um arquivo no seu computador. O arquivo deve ser gravado no formato JSON. Explore o arquivo e confirme a validade do seu formato.

```{r Q13}
con$export(file("meuarquivo.json"))
#Dá pra ler como txt
#800KB
```


###Questão 14
  Exporte o banco de dados para um arquivo no seu computador. O arquivo deve ser gravado no formato BSON. Explore o arquivo e confirme a validade do seu formato. Compare os tamanhos de ambos os arquivos.

```{r Q14}
con$export(file("meuarquivo.bson"), bson=TRUE)
#Não dá para ler como txt
#615KB
```


###Questão 15
  Remova do banco de dados a coleção com que você está trabalhando. Conte o número de observações existentes no banco de dados após a remoção.

```{r Q15}
con$count()
con$drop()
con$count()
```


###Questão 16
  Utilizando o método import(), importe o arquivo BSON criado por você diretamente para o banco de dados. Conte o número de observações existentes após a importação.

```{r eval=FALSE}
con$count()
#con$inport(file("meuarquivo.json"))
con$import(file("meuarquivo.bson"), bson=TRUE)
con$count()
```


####Documentação
https://jeroen.github.io/mongolite/
https://docs.mongodb.com/manual/reference/operator/
